#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

#
# Implements the k-Means clustering algorithm
#
# Main functions in script: update_assignments(X, C)
#                           update_centers(X, C, a)
#                           lloyd_iteration(X, C)
#                           Returns centroids and cluster assignments
#


all_equal = function(matrix[double] X1, matrix[double] X2)
    return(boolean equivalent) {
  /*
   * Determine if two matrices are equivalent.
   *
   * Inputs:
   *  - X1: Inputs, of shape (any, any).
   *  - X2: Inputs, of same shape as X1.
   *
   * Outputs:
   *  - equivalent: Whether or not the two matrices are equivalent.
   */
  equivalent = as.logical(prod(X1 == X2))
}

print ("BEGIN K-MEANS SCRIPT");
print ("Reading X...");


update_assignments = function(matrix[double] X, matrix[double] C) return (matrix[double] a) {
    # a is the cluster assignments(n,), 1-d array
    # a should be the size of the number of clusters since each example is assigned to a cluster
    a = matrix(0, rows = nrow(X), cols =1)

    # dist_array should be the size of the number of clusters since we're comparing the distance from cluster c, to each example Xi
    dist_array = matrix(0,rows = 1, cols = nrow(C))

    # loop in range of examples
    for (i in 1:nrow(X)) {
        # Iterate through each cluster c, and compute euclidean dist. with example i
        for(c in 1:nrow(C)){
            diff = X[i,]-C[c,]
            #print("Diff: " + toString(diff))
            sq_diff = diff^2
            #print("sq_diff: " + toString(sq_diff))
            sum_sq_diff = rowSums(sq_diff)
            #print("Sum of Squared difference: " + toString(sum_sq_diff))
            sqrt_sum_sq_diff = (sum_sq_diff)^0.5
            #print("Sqrt of Sum of Squared difference: " + toString(sqrt_sum_sq_diff))
            dist_array[,c] = sqrt_sum_sq_diff
            #print("Distance array: " + c + " || " +toString(dist_array[c,]))
        }
        # Find min distance of example i and each cluster, c, and return the index of that min.
        #a[i,] = colMins(dist_array)
        a[i,] =rowIndexMin(dist_array)
        #print("Real distance array i.e. vector: " + toString(dist_array))
    }
    #print("cluster assignments: "+ toString(a))
}

update_centroids = function(matrix[double] X, matrix[double] C, matrix[double] a) return(matrix[double] C) {

    # Input(s):
    # X is the data matrix
    # C is the cluster centers
    # a is the cluster assignments
    # Output(s):
    # C is the new cluster centers

    # K is a dxc matrix where c is the number of cluster centers and d is the number of features in the data, X
    # The K matrix will include the sum of each dimension with it's associated cluster value
    K = matrix(0, rows = ncol(X), cols = nrow(C))
    counter = matrix(0, rows = ncol(X), cols = nrow(C))
    #print("counter up top: " + toString(counter))
    for (k in 1:nrow(X)){
        # iterate through the features (dimensions) in the data, X
        for (i in 1:ncol(X)){
            colum_val = as.scalar(a[k,])
            K[i,colum_val] = K[i,colum_val]+ X[k,i]
            counter[i,colum_val] = counter[i,colum_val]+ 1
        }
    }
    K = (1/counter)*K
    #print("K matrix: " + toString(K))
    #print("Counter matrix: " + toString(counter))
    C = t(K)
    #print("C matrix: " + toString(C))
}

lloyd_iteration = function(matrix[double] X, matrix[double] C) return(matrix[double] C, matrix[double] a) {

    a = matrix(0, rows = nrow(X), cols = 1)
    a_new = matrix(1, rows = nrow(X), cols = 1)
    i = 1
    while(i==1){
        a = update_assignments(X,C)
        C = update_centroids(X,C,a)
        b = all_equal(a,a_new)
        if(b){
            i =0
        }
        a_new = a
    }
}
#mat = matrix("2.82567342 3.48211723 2.54247096 3.2465213 2.7973131 3.37056099 2.40967302 2.63335159 3.18890867 2.84827139 2.82567342 3.48211723 2.54247096 3.2465213 2.7973131 3.37056099 2.40967302 2.63335159 3.18890867 2.84827139 11.96116168 10.54895914 11.39193332 10.84828654 10.90694594 11.45929739 11.60220581 12.04742288 10.63745073 11.52199586", rows = 6, cols = 5)
#cen = matrix("1 4 5 7 9 1 2 1 3 4",rows = 2, cols =5)
#mat = matrix("2 3 1 4 2 4 6 3 9 3 5 2",rows = 6, cols = 2)
#cen = matrix("1 1 4 3 ", rows = 2, cols = 2)
#print("cen els " + toString(cen))
#print("mat elems " + toString(mat))


#a = update_assignments(mat,cen)
#C = update_centroids(mat,cen,a)

[centroid, assignments] = lloyd_iteration(mat, cen)
print("centroids: "+toString(centroid))
print("cluster assignments: " + toString(assignments))
print("Finished")
